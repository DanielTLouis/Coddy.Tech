Private Attributes



Private attributes use underscores to indicate that certain data should not be accessed directly from outside the class.

Why do we need private attributes? Imagine you have a bank account. You don't want anyone to directly change your balance - they should go through proper channels (deposit/withdraw methods) so the bank can validate the transaction, check for fraud, keep records, etc. Private attributes work the same way - they protect your data from being changed incorrectly.

Here is an example using single underscore (convention for "internal use"):

class Person:
    def __init__(self, name, age):
        self._name = name    # "protected" - internal use
        self._age = age      # "protected" - internal use
Single underscore attributes can still be accessed, but it's a signal not to:

person = Person("Alice", 30)
print(person._name)  # Works, but not recommended
Use double underscores for stronger privacy (name mangling):

class Person:
    def __init__(self, name, age):
        self.__name = name   # "private" - gets name mangled
        self.__age = age     # "private" - gets name mangled
    
    def get_name(self):
        return self.__name
    
    def set_age(self, age):
        if age >= 0:
            self.__age = age
        else:
            print("Age must be positive!")
Why use getter and setter methods? They're like gatekeepers. Instead of letting anyone change __age directly (which could result in negative ages or other invalid data), we force them to use set_age() which validates the input first. This prevents bugs and ensures data integrity.

The "extra code" has a purpose:

get_name() - Controlled access to read the name
set_age(age) - Validates age before allowing changes (no negative ages!)
Without these methods, someone could set age = -100 and break your program
Use the accessor methods to interact with private attributes:

person = Person("Bob", 25)
print(person.get_name())  # Bob

person.set_age(30)        # Valid: age becomes 30
person.set_age(-5)        # Invalid: Age must be positive! (age stays 30)
See the benefit? The set_age() method prevents invalid data. Without it, you could accidentally create a person with age -5, which makes no sense!

Double underscore attributes get "name mangled" but can still be accessed:

person = Person("Charlie", 35)
# This doesn't work:
# print(person.__name)  # AttributeError

# But this works (discouraged):
print(person._Person__name)  # Charlie
Real-world example - Why all this code?

class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # Private: can't be changed directly
    
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            return True
        return False
    
    def get_balance(self):
        return self.__balance

# Without private attributes:
# account.__balance = -1000000  # Disaster! Negative balance allowed

# With private attributes:
account = BankAccount(100)
account.deposit(50)           # Safe: validated
print(account.get_balance())  # 150
The "extra code" (methods) protects your data from invalid changes. It's like having security guards instead of leaving your valuables unprotected.

Output:

Alice
Bob
Age must be positive!
Charlie
Key Point: Single underscore _attribute means "internal use only" by convention. Double underscore __attribute triggers name mangling for stronger privacy. Use getter/setter methods (accessor methods) to properly interact with private data and add validation. The "extra code" prevents bugs by ensuring data is always valid.
